---
title: "Building Individually Targeted Improvement Plan for Hitters"
author: "Allen Ho"
date: "2021/6/15"
output: html_document
---

```{r setup, include=F}
knitr::opts_chunk$set(echo=T, 
                      warning=F, 
                      message=F,
                      cache = T,
                      include = T,
                      error = F)
```

## Introduction

Group players according to their ability to do damage on contact (the Blast practice data). Then build individually targeted improvement plans for all of the hitters by evaluating their in-game performance (xwOBA).

## Method

Data include pitch level Trackman data from games and swing level Blast Motion data from practice.

Performed cluster analysis on practice data (Blast) and came up with four groups.

To make development plans for them, I had to see the characteristics of these four groups and their respective in-game performance. xwOBA for those contact plays is my choice for evaluation.

## Exploratory Data Analysis

### Packages needed:
```{r loadlib}
install.packages("ggplot2")
install.packages("DMwR")
install.packages('VIM')
install.packages('ggfortify')
library(ggplot2)
library(DMwR)
library(VIM)
library(ggfortify)
```

### Import the data
```{r data}
df.trackman = read.csv('C:/Users/allen/Desktop/Baseball Analytics Coding Task/trackman_data.csv')
df.blast = read.csv('C:/Users/allen/Desktop/Baseball Analytics Coding Task/blast_data.csv')
```

### Top 5 rows of the dataframe
```{r head}
head(df.trackman)
head(df.blast)
```

### Structure of the dataframe
```{r structure}
str(df.trackman)
str(df.blast)
```

### Summary of the dataframe
```{r summary}
summary(df.trackman)
summary(df.blast)
```

### NaN values
```{r NaN}
colnames(df.trackman)[colSums(is.na(df.trackman)) > 0]
colnames(df.blast)[colSums(is.na(df.blast)) > 0]
```

### KNN imputation
A popular approach to missing data imputation is to use a model to predict the missing values. This requires a model to be created for each input variable that has missing values. Although any one among a range of different models can be used to predict the missing values, the k-nearest neighbor (KNN) algorithm has proven to be generally effective, often referred to as “nearest neighbor imputation.”
```{r KNN imputation}
knnOutput <- kNN(df.trackman, variable=c("PlateSide", "PlateHeight", "ExitSpeed", "VertAngle", "HorzAngle", "HitSpinRate"), k=5)
anyNA(knnOutput)
```

To properly evaluate the damage done by each batter, I will come up with the xwOBA value for each plate appearance. xwOBA is a rate stat like batting average or slugging percentage, but uses weights that accurately represent the relative value of each type of outcome. Fangraphs has these values tabulated. With an out worth 0, a single is worth around 0.88, for example. If I take those weights and use them with my hit probabilities, I can calculate an expected wOBA, or xwOBA.

MLB Blogs chose not to include batted ball spray angle in their model of xwOBA, claiming they haven't found evidence that it contributes significantly to a better or worse outcome. They may well be right -- just to reiterate, I'm including it to see how well outcomes are modeled by all the things a hitter can control. It might turn out that their model outperforms mine, or is better at predicting how a player performs in the future.

I will only include rows that contain 'ExitSpeed', 'VertAngle', 'HorzAngle'value since those are the ones that are core of the xwOBA value.

## Probability Density Function
A Probability density function (PDF) is a function whose value at any given sample in the set of possible values can be interpreted as a relative likelihood that the value of the random variable would equal that sample. In other words, the value of the PDF at two different samples can be used to infer, in any particular draw of the random variable, how much more likely it is that the random variable would equal one sample compared to the other sample.

The distribution of data from Blast
```{r Probability Density Function}
standardize <- as.data.frame(scale(df.blast[,c("AttackAngle", "BatSpeed", "Connection", "EarlyConnection", "PlanarEfficiency", "RotationalAcceleration")]))

plot(density(standardize$AttackAngle),
     col=1,
     xlim = c(- 6, 6),
     ylim = c(0, 0.6),
     main="Probability Density Function of Blast Data",
     xlab="Z-score",
     ylab="PDF")
lines(density(standardize$BatSpeed),
      col = 2)
lines(density(standardize$Connection),
      col = 3)
lines(density(standardize$EarlyConnection),
      col = 4)
lines(density(standardize$PlanarEfficiency),
      col = 5)
lines(density(standardize$RotationalAcceleration),
      col = 6)
legend(2, 0.5, legend=c("AttackAngle", "BatSpeed", "Connection", "EarlyConnection", "PlanarEfficiency", "RotationalAcceleration"),
       col=c(1, 2, 3, 4, 5, 6), lty=1, cex=0.8)
```

# Mean value of data from blast with different BatterId
```{r mean value}

```
